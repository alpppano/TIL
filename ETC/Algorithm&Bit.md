## 알고리즘

- 문제를 해결하기 위한 절차나 방법
- 공간적 효율성 vs 적은 시간
    - 적은 메모리 공간, 적은 시간
    - 복잡도가 높을수록 효율성은 저하됨

### O(Big-Oh) 표기

- 복잡도 표현은 가장 높은 차수에서 앞에 숫자는 떼고 표현
- O(N) 처럼 표기, 미세하게 성능 차이를 강조한다면 O(5N)처럼 표기하기도
- O(log N) 보다 O(1)이 빠르지만 유사한 성능
- O(NlogN) 보다 O(N)이 빠르지만 유사한 성능

- sort() ⇒ O(N log N) 보장함
- 알고리즘 시간 복잡도 계산 많이 해보기

## 비트 연산

- 비트 연산자로 계산하는 십진수도 이진수로 자동으로 바꿔서 계산
- CPU는 0과 1로 동작, 덧셈/뺄셈/곱셈 등을 계산
    - 코드를 메인메모리(RAM)에 저장하고 가져와서 계산
- 연산자
    - &: and
        - 각 자릿수끼리 비교해서 결과 표현
    - |: or (둘 중 하나가 1이면 1)
- 2진수, 16진수 표현
    - 2진수: 0b를 접두사로 붙여서 표현
    - 16진수: 0x를 접두사로 붙여서 표현

    ```python
    print(bin(10)), print(hex(10))
    print(int(’1011’, 2) # 2진수
    # A는 10이다
    ```
    
- ^: XOR(같으면 0 다르면 1)
    - 어떤 값이던 XOR을 2번 하면 원래 수로 돌아옴
- <<(left shift), >>(right shift)
    - 특정 수만큼 비트를 왼쪽, 오른쪽으로 밀어낸다
    - ex. i & (1<<n)
        - i의 n번째 비트가 1인지 아닌지 - 결과값이 0이 아니면 비트는 1임
    - 부분집합 만들기
        
        ```python
        for i in range(1<<len(arr)):
            for idx in range(len(arr)):
                if i & (1 << idx):
                    print(arr[idx], end = ' ')
            print()
        ```
        
- 음수 표현(맨 앞이 1)
    - 2의 보수
        - 반전 이후 +1
        - 연산할 때는 더하고 난 후 맨 앞자리를 제외하고 보면 계산 결과
    - 2의 보수를 두 번 하면 원래 숫자로 돌아옴
- NOT 연산자(~숫자)
    1. 비트를 반전
    2. 부호 비트 제외
    3. 2의 보수
- 실수 출력 방법
    - print(f’변수 {num: .2f}’) - 소수점 둘째자리에서 반올림하여 표현
    - 실수는 정확한 값이 아니라 근사값으로 저장 → 오차가 계산 과정에서 다른 결과 발생
    - 비트로 표현하면 무한 반복되는 숫자끼리 더하면 결과가 오차 범위 내에 있을 경우만 제대로 계산됨
- 부동소수점
    - 부호 1비트: 0이면 양수, 1이면 음수
    - 지수 8비트: 부동소수점 크기 + bias값
    - 가수부: 실질적 수