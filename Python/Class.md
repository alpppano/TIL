| 절차 지향 | 객체 지향 |
| --- | --- |
| 데이터와 해당 데이터를 처리하는 함수(절차)가 분리 | 데이터와 해당 데이터를 처리하는 메서드(메시지)를 하나의 객체(클래스)로 묶음 |
| 함수의 재사용보다 함수 호출의 흐름이 중요 | 객체 간 상호작용과 메시지 전달이 중요 |
|  | 절차 지향을 보완하기 위한 패러다임 |

### 객체

클래스에서 정의한 것을 토대로 메모리에 할당된 것

속성(변수)과 행동(메서드)으로 구성된 모든 것

- 타입(type)
    - 어떤 연산자(operator)와 조작(method)이 가능한가
- 속성(attribute)
    - 어떤 상태(데이터)를 가지는가
- 조작법(method)
    - 어떤 행위(함수)를 할 수 있는가

### 인스턴스

- 클래스로 만든 객체
- ex. name = ‘SSAFY’
    - name은 str클래스로 만든 인스턴스

## 1. 클래스

파이썬에서 타입 표현하는 방법

객체를 생성하기 위한 설계도

데이터와 기능을 함께 묶는 방법 제공

### 클래스 정의

- 클래스 이름은 Pascal Case로 작성
- 변수 = 속성

*Camel Case: myClass

*Pascal Case: MyClass

*Snake Case: myclass


## 2. 변수

1. 클래스 변수(클래스 속성)
    1. 클래스 내부에 선언된 변수
    2. 클래스로 생성된 모든 인스턴스들이 공유하는 변수
    3. 클래스 변수를 바꾸면 인스턴스들이 갖고 있던 클래스 변수들도 바뀜



2. 인스턴스 변수(인스턴스 속성) 
    1. 인스턴스마다 별도로 유지되는 변수
    2. 인스턴스 생성할 때마다 초기화
    3. self.name =name 의미
        1. self 인스턴스의 변수 name을 만들고 그 값을 name으로 하겠다


---

## 3. Method

### 인스턴스 메서드

- 클래스로부터 생성된 각 인스턴스에서 호출할 수 있는 메서드
    - 인스턴스 상태 조작하거나 동작 수행
- **반드시 첫 번째 parameter로 인스턴스 자신(self)를 받음**
    - self 변수명은 바꾸지 말 것



**self 동작 원리**

- 파이썬 내부에서는 절차 지향 방식으로 이해하는데 클래스의 메서드에 인스턴스를 넣는 방식으로 이해함 → 인스턴스 메서드에는 self를 먼저 넣어줘야 함
    - ex. str 클래스가 upper 메서드를 호출 후 (인스턴스)를 넣는 구조

```
'hello'.upper()  # 객체 지향 방식(단축형 호출)

str.upper('hello')  # 실제로 파이썬 내부 동작하는 방식
```

**생성자 메서드**

- 객체를 생성할 때 자동으로 호출
- __init__ 이라는 이름의 메서드로 정의,
객체 초기화 담당
- 인스턴스 생성 시 자동 호출,
필요한 초기값 설정
    - 초기값을 넣지 않으면 생성 X
- 생성자 메서드를 생략하면 자동으로 생성
    - But, 쓰는 걸 권장함



### 클래스 메서드

- 클래스 변수 조작, 클래스 레벨의 동작 수행
- @classmethod 데코레이터를 사용하여 정의
- **첫 번째 인자로 해당 method를 호출하는 클래스가 전달됨**
    - 호출하기 전까지 cls는 어떤 클래스를 지칭하는지 알 수 없음
    - cls로 하는 이유는 상위 클래스 안에 하위 클래스가 있을 수도 있기 때문



### 정적(static) 메서드

클래스와 인스턴스와 상관없이 독립적으로 동작하는 메서드

- 필수로 작성할 parameter가 없음
- 클래스가 호출함 → 인스턴스 생성 안 해도 사용 가능



| 클래스 메서드 | 인스턴스 메서드 | 스태틱 메서드 |
| --- | --- | --- |
| 클래스 변수 조작, 클래스 레벨 동작 | 인스턴스 상태 변경, 특정 동작 | 둘 다 관련 없는 일반적인 기능 |
| @classmethod |  | @staticmethod |
| cls가 첫 번째 매개변수 | self가 첫 번째 매개변수 |  |
| 클래스가 사용할 것 | 인스턴스만 쓰도록 | 클래스가 사용할 것 |
- 각 메서드는 목적에 따라 설계됐기 때문에 올바른 메서드만 사용

## 4. 독립적인 이름 공간

- 클래스 정의 → 클래스와 해당하는 이름 공간 생성
- 인스턴스 만들면 인스턴스 객체, 독립적인 이름 공간 생성
    - 인스턴스 이름 공간에 데이터가 없다면 클래스 이름 공간을 참조함
- 장점
    - 독립성, 재사용성

## 5. 매직 메서드(스페셜 메서드)

- 특정 상황에 자동으로 호출되는 메서드
- __func__ 형태
- ex. __str__(self)
    - print될 때 자동 실행 → 출력문 해당 문자열로 수정해줌
    - 이 함수 내에 print를 쓰지 말고 return으로 반환값 가져와서 print하기

## 6. 데코레이터

- 다른 함수 코드를 유지한 채 수정하거나 확장


## 7. 상속

기존 클래스 속성, 메서드를 물려받아 새로운 하위 클래스 생성

- 코드 재사용
    - 기존 클래스 기능을 그대로 활용해 코드 중복을 줄일 수 있음
- 계층 구조
    - 부모 - 자식 클래스 간 관계 표현 가능
- 유지 보수 용이
    - 기존 클래스 수정이 필요하면 해당 클래스만 수정하면 됨
    - 코드의 일관성 유지, 수정 범위 최소화
- 단일 상속
    - 상속할 부모 클래스의 생성자 함수의 매개변수는 그대로 써줘야 함


- 다중 상속
    - 둘 이상의 상위 클래스로부터 상속
    - 상속 받은 모든 클래스 요소 활용 가능
    - 상속할 부모 클래스의 생성자 함수의 매개변수는 그대로 써줘야 함
    - MRO: 중복된 속성이나 메서드가 있으면 상속 순서에 따라 결정됨
        - 해당 클래스의 매개변수에 작성된 순서대로(왼 → 오)
        
        
        
- **super()**
    - MRO 순서에 따라 부모 클래스의 변수, 메서드를 가져옴
    - super()__init__(매개변수에 부모 클래스의 매개변수 중 self 빼고 다 적어줘야 함)
        - 만약 상속 받는 부모 클래스의 매개변수가 다를 경우, 해당 부모 클래스의 메서드를 사용하려면 그 매개변수들을 다 적어줘야 함
        - child 클래스의 매개변수로 받은 값을 super를 통해 parent에게 전달해주고 그 값으로 parent의 메서드를 호출
    
    - classmethod 에서 cls로 호출하면 부모 클래스 메서드를 전체 호출 가능
    
    
    - 단일 상속에서 장점
        - 클래스 이름 변경, 부모 클래스가 교체돼도 super()사용 하면 수정 필요없음
    - 다중 상속에서 장점
        - 복잡한 다중 상속 구조에서 문제 방지