# 배열

문제를 해결하기 위한 절차나 방법

### 참고

1. i, j 등은 데이터를 직접 가져올 때는 가급적 사용하지 않는 것이 좋음( x, y 등 사용)

### 좋은 알고리즘?

1. 정확성
2. 작업량: 적은 연산으로 원하는 결과를 얻는지
    - 시간 복잡도
        - 실제 걸리는 시간
        - 실행되는 명령문 개수 계산
    - Big-O 표기법
        - 가장 큰 영향력을 주는 n에 대한 항만을 표시
    
3. 메모리 사용량: 적은 메모리 사용
4. 단순성
5. 최적성: 개선할 여지 없이 최적화 됐는지

### 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

다수의 변수로는 하기 힘든 작업을 편하게 할 수 있음

### 1차원 배열

배열의 크기를 먼저 정해두고 할당하는 게 좋음

- append는 시간이 많이 걸리는 작업이므로 지양

### 2차원 배열

- 1차원 리스트를 묶어 놓은 리스트
- 차원에 따라 index 선언
- 2차원 배열 출력 방법

```jsx
1차원 배열
for i in range(n):
	print(*arr2[i])

2차원 배열
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

n행 m열 2차원 배열(행 우선 순회)
for i in range(n):
	for j in range(m):
		print(arr2[i][j])
	print()
	
n행 m열 2차원 배열(열 우선 순회)
for i in range(m):
	for j in range(n):
		print(arr2[i][j])
	print()
```

- 지그재그 순회(n행 m열)

```jsx
for i in range(N):
    for j in range(M):
        print(arr[i][j + (M-1-2*j) * (i%2)])
```

### 델타를 이용한 2차 배열 탐색

- 움직일 방향을 미리 리스트에 담아두는 것

```
# 행 i 열 j 배열 크기 NxN
# 움직일 행, 열 좌표값
di = [-1, 1, 0, 0]    # 상하좌우
dj = [0, 0, -1, 1]

for k in range(4)
	ni = i + di[k]
	nj = j + di[k]
	if 0 <= ni < N and 0 <= nj < N:
		print(arr[ni][nj])
```

```
# 현재 위치 좌표
    x = 0
    y = 0
    location = [x, y]

    dx = [0, 1, 0, -1]          # 움직일 x축 방향 설정
    dy = [1, 0, -1, 0]          # 움직일 y축 방향 설정
    direction = 0               # 상황에 따라 움직일 방향 결정할 변수

    for i in range(1, N*N + 1): # 작성할 숫자만큼 반복
        arr[x][y] = i           # 현재 위치에 숫자 넣기
        nx = x + dx[direction]  # 다음 위치는 현재 위치 + x축 방향
        ny = y + dy[direction]  # 다음 위치는 현재 위치 + y축 방향

        if nx > N-1 or ny > N-1 or nx < 0 or ny < 0 or arr[nx][ny] != 0:        # 사각형을 벗어나거나 다음 위치가 숫자가 이미 적혀 있으면
            direction = (direction + 1) % 4     # 방향 재설정. 방향은 4번 바꾼 후 다시 처음 방향이므로 4로 나눈 나머지
            nx = x + dx[direction]              # 다음 위치를 재설정한 방향으로 변경
            ny = y + dy[direction]
        x, y = nx, ny
```

```
델타탐색, 스택을 이용해서 출발지점 -> 도착지점까지 갈 수 있는지

dx = [-1, 1, 0, 0]  # 상하좌우
dy = [0, 0, -1, 1]

# for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)] # 이렇게도 가능

def search(x, y):
    stack = [(x, y)]    # 스택에 출발지점 할당
    visited[x][y] = 1   # 출발지점은 방문한 것으로 체크

    while stack:
        x, y = stack.pop()    # 현재 위치: 스택에서 꺼내온 x,y
        # 상하좌우 탐색
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            # 다음 좌표가 범위를 벗어나지 않고 벽이 아니고 방문하지 않았는지
            if 0 <= nx < N and 0 <= ny < N and arr[nx][ny] != 1 and visited[nx][ny] != 1:
                if arr[nx][ny] == 3:
                    return 1    # 다음 위치가 출구면 1 반환 후 함수 종료
                # 출구 값인 3이 아니라면
                stack.append((nx, ny))   # 스택에 추가(이 좌표는 갈 수 있는 길이다)
                visited[nx][ny] = 1      # 방문한 것으로 체크
    return 0   # 출구 값을 못 찾으면 0 반환
```

### 전치 행렬(행, 열 바꾸기)

```
# 대각선을 기준으로 마주보는 값만 바꾸기
for i in range(n):
	for j in range(m):
		if i < j:
			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

- 대각선 역으로 합산
    - if (N-1) - i == j
    - if arr[i][-(i+1)]

### 부분집합

- for문을 요소만큼 돌리면 됨

```jsx
bit = [0, 0, 0]
for i in range(2):
	bit[0] = i
	for j in range(2):
		bit[1] = j
		for k in range(2):
			bit[2] = k
```

```

subsets = [[]]

for x in arr:
	for i in range(len(subsets)):
		subset = subsets[i] + [x]
		  if subset not in subsets:
	      subsets += [subset]    # subsets.append(subset)
```
### 비트 연산자

- 장점: 원소의 개수가 변할 때 for문의 개수를 수정하지 않아도 됨


# 정렬

### 1. 버블 정렬

- 진행 방식
    - 인접한 2개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 첫 번째 원소부터 인접한 원소끼리 자리를 교환하면서 맨 마지막까지 이동
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
- 장점: 코딩이 쉽다
- 단점: 시간이 오래 걸림
    - 복잡도: O(n^2)


### 2. 카운팅 정렬

- 각 항목이 몇 개씩 있는지 세어 선형 시간에 정렬
- 복잡도: O(n+k)
- 장점: 코드가 짧지만 이해하기 어려움
- 제한사항
    - 정수나 정수로 표현할 수 있는 자료에만 적용 가능
    - 집합 내 가장 큰 정수를 알아야 함

---

- 1단계: Data에 각 항목이 몇 개씩 있는가

1. counts 변수에 빈 공간을 세고 싶은 항목 만큼 생성
2. Data에서 하나씩 꺼내와서 해당하는 counts에 +1

- 2단계: 특정 항목까지 누적 개수가 몇 개인가
    - 정렬할 때 특정 항목이 몇 번부터 시작되는지 알 수 있음
    - ex. 정렬 시 숫자 3은 6번째부터 정렬됨

1. 특정 항목까지 누적 개수 = 이전 항목까지의 개수 + 특정 항목의 개수

- 3단계: 자료 정렬

1. Data의 특정값에 해당하는 누적값을 찾는다 (항상 맨 마지막 값부터 시작)
    1. Data 값의 위치가 고정되어 있는 경우가 있기 때문에 앞에서부터 시작하면 정렬할 때 위치가 바뀔 수 있음
2. Counts의 index가 0부터 시작이고 0은 위치가 고정이기 때문에 숫자는 1부터 정렬
→ counts(누적 개수) 값에서 -1뺀 index에 해당 값 정렬

```
data = [1,2,4,3,2,1,9]
counts = [0] * (9+1)           # data의 가장 큰 원소만큼 만들기(0 포함)
N = len(data)
temp = [0] * N                 # data 길이만큼 임시 공간 만들기

# data 원소별 개수를 counts[데이터 원소]에 저장
for x in data:
	counts[x] += 1

# counts를 누적 개수로 변환하기
for i in range(1, len(counts)):   # 0은 항상 처음 고정이기 때문에 1부터 누적 개수로 변환
	counts[i] = counts[i-1] + counts[i]   # 해당 원소값 바로 앞의 원소값을 더함
	
# data 원소들을 temp 값에 차례대로 넣기
for i in data:        # 누적 값에서 -1 뺀 값이 해당 값의 인덱스(숫자는 0부터 시작하기 때문)
	counts[i] -= 1                  # 원소에 해당하는 counts 누적 값을 1 감소
	temp[counts[i]] = i             # 원소에 해당하는 counts 값을 인덱스로 temp에 넣기

```

### 2-1. 딕셔너리를 활용한 카운팅 정렬

```jsx
*# 갯수 세기를 위한 딕셔너리 생성
    cnt_dic = {k : 0 for k in num_in_string}

    # 문자를 하나씩 순회하며, 각 등장할때마다 딕셔너리 해당 키값으로 + 1
    for s in str_li : cnt_dic[s] += 1

    # 출력하기
    print(T)
    for s in num_in_string :        # 하나씩 순회하며, 등장 횟수만큼 출력을 진행
        for _ in range(cnt_dic[s]) : print(s, end = " ")*
```

<완전 검색>

- 모든 경우의 수를 나열해보고 확인
- 경우의 수가 작을 때 유용

### 탐욕 알고리즘

- 각 단계에서 최적이라고 생각되는 것을 선택
- 선택 절차 → 적절성 검사 → 해답 검사

<빈 칸 없는 숫자 받는 법>

```jsx
num = 456789
c = [0] * 12
list(map(int, input()))  # split()으로 쪼개지 않고 문자열의 순서대로 가져와서 숫자로 변환

for i in range(6):       # 해당 숫자의 자릿수를 알고 있는 경우
	c[num % 10] += 1       # 1의 자리부터, 10으로 나눈 나머지에 해당하는 리스트의 자리에 1 카운트
	num //= 10             # 1의 자리는 기록했으니 10으로 나눈 몫을 할당해 1의 자리를 삭제
```

### 3. 선택 정렬

- 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환
- 과정
    1. 주어진 구간에 대해 기준 위치 i 설정
    2. 최솟값이 들어갈 위치를 기준 위치 i로 가정
    3. 기준 위치 이후의 원소에 대해 실제 최솟값 위치 검색
    4. 기준 위치 원소와 최솟값 자리 바꾸기


# 검색

## 1. 순차 검색

- 가장 간단하고 직관적
- 배열, 연결 리스트 등 순차구조일 때 유용
- 검색 대상의 수가 많을 경우 비효율적

### 검색 과정

1. 첫 번째 원소부터 검색 대상과 키 값이 같은 원소가 있는지 비교
2. 찾으면 인덱스 반환
3. 마지막까지 못 찾으면 검색 실패

**<자료가 정렬되어 있지 않은 경우>**

- 평균 비교 횟수 : (n+1)
- 시간 복잡도: O(n)

**<자료가 정렬되어 있는 경우>**

- 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어듦
- 시간 복잡도: O(n)
- 주의할 점:
    - 조건 중 인덱스를 이용한 검색은 항상 오른쪽에 작성
    
    ```
    # 단축평가로 왼쪽이 False면 오른쪽 검사를 하지 않음
    #인덱스를 이용한 검색이 out of range 오류가 나는 상황이라면 오류 발생
    
    while a[i] < key and i < n:    
    ```
    

## 2. 이진 검색

- 자료의 가운데에 있는 항목과 키 값을 비교 → 다음 검색의 위치를 결정하여 계속 진행
- 검색 범위를 반으로 줄여가면서 보다 빠르게 수행
- 정렬된 상태여야 함
- 자료의 삽입이나 삭제가 발생했을 때 항상 정렬 상태로 유지하는 추가 작업이 필요

## 3. 인덱스

- 배열 인덱스 사용
- 데이터베이스 인덱스는 이진 탐색 트리 구조